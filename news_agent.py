import logging
import smtplib
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from pathlib import Path

import anyio
from claude_agent_sdk import (
    AssistantMessage,
    ClaudeAgentOptions,
    ResultMessage,
    TextBlock,
    query,
)
from dotenv import dotenv_values

LOG_PATH = Path(__file__).parent / "news_agent.log"

logging.basicConfig(
    filename=LOG_PATH,
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
)
log = logging.getLogger(__name__)

TOPICS = ["Tech & AI", "Finance & Markets", "World News"]

PROMPT = (
    "Search the web for today's top news stories. "
    "For each of the following three topics, find the 3 most important stories "
    "and write a 1-2 sentence summary of each.\n\n"
    "Topics:\n"
    + "\n".join(f"- {t}" for t in TOPICS)
    + "\n\n"
    "Format your response exactly like this, using these headers:\n"
    "## Tech & AI\n"
    "## Finance & Markets\n"
    "## World News\n\n"
    "Under each header, list the stories as numbered items."
)


def load_config() -> dict[str, str]:
    config_path = Path(__file__).parent / "config.env"
    config = dotenv_values(config_path)
    required = ["GMAIL_ADDRESS", "GMAIL_APP_PASSWORD", "RECIPIENT_EMAIL"]
    missing = [k for k in required if not config.get(k)]
    if missing:
        raise ValueError(f"Missing config keys: {', '.join(missing)}")
    return config


TOPIC_ICONS = {
    "Tech & AI": "\U0001F4BB",       # laptop
    "Finance & Markets": "\U0001F4C8",  # chart increasing
    "World News": "\U0001F30D",      # globe
}


def briefing_to_html(briefing: str, date_str: str) -> str:
    sections: list[str] = []
    current_items: list[str] = []
    current_heading: str | None = None

    def flush_section() -> None:
        if current_heading is not None:
            icon = TOPIC_ICONS.get(current_heading, "\U0001F4F0")
            items_html = "\n".join(current_items)
            sections.append(
                f'<div style="background:#f8f9fa;border-radius:8px;'
                f'padding:20px 24px;margin-bottom:24px;">'
                f'<h2 style="color:#1a73e8;margin:0 0 16px 0;'
                f'font-size:22px;">{icon} {current_heading}</h2>'
                f"{items_html}</div>"
            )

    for line in briefing.splitlines():
        stripped = line.strip()
        if stripped.startswith("## "):
            flush_section()
            current_heading = stripped[3:]
            current_items = []
        elif stripped:
            current_items.append(
                f'<p style="margin:0 0 14px 0;line-height:1.6;'
                f'font-size:15px;color:#333;">{stripped}</p>'
            )

    flush_section()

    body = "\n".join(sections)
    return (
        '<html><body style="margin:0;padding:0;background:#e8eaed;">'
        '<div style="max-width:600px;margin:0 auto;padding:32px 16px;">'
        f'<h1 style="color:#202124;font-size:28px;margin:0 0 8px 0;">'
        f"Daily News Briefing</h1>"
        f'<p style="color:#666;font-size:14px;margin:0 0 28px 0;">'
        f"{date_str}</p>"
        f"{body}"
        '<hr style="border:none;border-top:1px solid #ddd;margin:24px 0 12px 0;">'
        '<p style="color:#999;font-size:12px;text-align:center;">'
        "Generated by Claude Agent SDK</p>"
        "</div></body></html>"
    )


def send_email(
    sender: str,
    app_password: str,
    recipients: list[str],
    subject: str,
    html_body: str,
) -> None:
    msg = MIMEMultipart("alternative")
    msg["From"] = sender
    msg["To"] = ", ".join(recipients)
    msg["Subject"] = subject
    msg.attach(MIMEText(html_body, "html"))

    with smtplib.SMTP("smtp.gmail.com", 587) as server:
        server.starttls()
        server.login(sender, app_password)
        server.sendmail(sender, recipients, msg.as_string())


async def fetch_briefing() -> str:
    parts: list[str] = []
    async for message in query(
        prompt=PROMPT,
        options=ClaudeAgentOptions(
            allowed_tools=["WebSearch"],
            permission_mode="bypassPermissions",
            max_turns=5,
        ),
    ):
        if isinstance(message, AssistantMessage):
            for block in message.content:
                if isinstance(block, TextBlock):
                    parts.append(block.text)
        elif isinstance(message, ResultMessage):
            if message.result:
                parts.append(message.result)
    return "\n".join(parts)


async def main() -> None:
    log.info("Starting daily news briefing")
    try:
        config = load_config()
        briefing = await fetch_briefing()
        if not briefing.strip():
            raise RuntimeError("Empty briefing returned from Claude")

        today = datetime.now().strftime("%B %d, %Y")
        html = briefing_to_html(briefing, today)
        subject = f"Daily News Briefing - {today}"

        recipients = [
            r.strip() for r in config["RECIPIENT_EMAIL"].split(",")
        ]
        send_email(
            sender=config["GMAIL_ADDRESS"],
            app_password=config["GMAIL_APP_PASSWORD"],
            recipients=recipients,
            subject=subject,
            html_body=html,
        )
        log.info("Briefing sent successfully to %s", ", ".join(recipients))
    except Exception:
        log.exception("Failed to send briefing")
        raise


if __name__ == "__main__":
    anyio.run(main)
